import express from 'express';
import cors from 'cors';
import pg from 'pg';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { createServer } from 'http';
import { WebSocketServer } from 'ws';
dotenv.config();
const app = express();
const PORT = process.env.PORT || 4000;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const server = createServer(app);
const pool = new pg.Pool({ host: process.env.DB_HOST || '127.0.0.1', port: parseInt(process.env.DB_PORT || '6432'), database: process.env.DB_NAME || 'summit', user: process.env.DB_USER || 'summit_user', password: process.env.DB_PASSWORD, max: 20 });
const allowedOrigins = (process.env.CORS_ORIGIN || 'https://summit.codingeverest.com').split(',');
app.use(cors({ origin: (origin, callback) => { if (!origin || allowedOrigins.indexOf(origin) !== -1) callback(null, true); else callback(new Error('Not allowed by CORS')); }, credentials: true }));
app.use(express.json());
const wss = new WebSocketServer({ server, path: '/ws' });
const clients = new Map();
wss.on('connection', (ws, req) => { let token = null; if (req.url) { const urlParts = req.url.split('?'); if (urlParts.length > 1) { const queryParams = new URLSearchParams(urlParts[1]); token = queryParams.get('token'); } } if (!token) { ws.close(1008, 'No token'); return; } try { const decoded = jwt.verify(token, JWT_SECRET); console.log('WebSocket connected:', decoded.id); clients.set(decoded.id, ws); ws.userId = decoded.id; ws.send(JSON.stringify({ type: 'CONNECTED', userId: decoded.id })); ws.on('close', () => { clients.delete(decoded.id); console.log('WebSocket disconnected:', decoded.id); }); } catch (error) { console.error('WebSocket auth error:', error.message); ws.close(1008, 'Invalid token'); } });
function notifyUser(userId, message) { const client = clients.get(userId); if (client && client.readyState === 1) { try { client.send(JSON.stringify(message)); } catch (e) { console.error('Error sending to client:', e); } } }
function notifyChat(chatId, message, excludeUserId) { pool.query('SELECT user_id FROM chat_participants WHERE chat_id = $1', [chatId]).then(result => { result.rows.forEach(row => { if (row.user_id !== excludeUserId) { notifyUser(row.user_id, message); } }); }).catch(err => console.error('Error notifying chat:', err)); }
const authenticate = async (req, res, next) => { try { const authHeader = req.headers.authorization; if (!authHeader || !authHeader.startsWith('Bearer ')) return res.status(401).json({ error: 'Unauthorized' }); const token = authHeader.substring(7); const decoded = jwt.verify(token, JWT_SECRET); req.user = decoded; next(); } catch (error) { return res.status(401).json({ error: 'Invalid token' }); } };
app.get('/health', (req, res) => { res.json({ status: 'ok', websocket: 'enabled' }); });
app.post('/api/auth/login', async (req, res) => { try { const { email, password } = req.body; if (!email || !password) return res.status(400).json({ error: 'Email and password required' }); const result = await pool.query('SELECT * FROM users WHERE LOWER(email) = LOWER($1)', [email]); if (result.rows.length === 0) return res.status(404).json({ error: 'Account not found' }); const user = result.rows[0]; if (!user.password_hash) return res.status(401).json({ error: 'Invalid credentials' }); const isValid = await bcrypt.compare(password, user.password_hash); if (!isValid) return res.status(401).json({ error: 'Invalid credentials' }); const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, { expiresIn: '7d' }); res.json({ user: { id: user.id, email: user.email, name: user.name, avatar_url: user.avatar_url, company: user.company, job_title: user.job_title, phone: user.phone }, token }); } catch (error) { console.error('Login error:', error); res.status(500).json({ error: 'Login failed' }); } });
app.post('/api/auth/register', async (req, res) => { try { const { email, name, password, job_title, phone, company } = req.body; if (!email || !name || !password) return res.status(400).json({ error: 'Email, name, and password required' }); if (password.length < 6) return res.status(400).json({ error: 'Password must be at least 6 characters' }); const passwordHash = await bcrypt.hash(password, 10); const result = await pool.query('INSERT INTO users (email, name, password_hash, job_title, phone, company) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, email, name, avatar_url, company, job_title, phone', [email.toLowerCase(), name, passwordHash, job_title || null, phone || null, company || null]); const user = result.rows[0]; const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, { expiresIn: '7d' }); res.json({ user, token, message: 'Account created successfully!' }); } catch (error) { console.error('Register error:', error); if (error.code === '23505') return res.status(400).json({ error: 'User already exists' }); res.status(500).json({ error: 'Registration failed' }); } });
app.get('/api/users/search', authenticate, async (req, res) => { try { const { email } = req.query; if (!email) return res.status(400).json({ error: 'Email parameter required' }); const result = await pool.query('SELECT id, email, name, avatar_url, company, job_title FROM users WHERE LOWER(email) = LOWER($1)', [email]); if (result.rows.length === 0) return res.status(404).json({ error: 'No user found with this email address' }); res.json(result.rows[0]); } catch (error) { console.error('User search error:', error); res.status(500).json({ error: 'Search failed' }); } });
app.get('/api/chat-requests/contacts', authenticate, async (req, res) => { try { const userId = req.user.id; const result = await pool.query(`SELECT DISTINCT CASE WHEN cr.requester_id = $1 THEN cr.requestee_id ELSE cr.requester_id END as contact_id, u.email as contact_email, u.name as contact_name, u.avatar_url as contact_avatar_url, u.company as contact_company, u.job_title as contact_job_title FROM chat_requests cr JOIN users u ON (CASE WHEN cr.requester_id = $1 THEN cr.requestee_id ELSE cr.requester_id END) = u.id WHERE (cr.requester_id = $1 OR cr.requestee_id = $1) AND cr.status = 'accepted' ORDER BY u.name, u.email`, [userId]); res.json(result.rows); } catch (error) { console.error('Get contacts error:', error); res.status(500).json({ error: 'Failed to get contacts' }); } });
app.get('/api/chat-requests/received', authenticate, async (req, res) => { try { const userId = req.user.id; const result = await pool.query(`SELECT cr.id, cr.requester_id, cr.status, cr.created_at, u.email as requester_email, u.name as requester_name, u.avatar_url as requester_avatar_url FROM chat_requests cr JOIN users u ON cr.requester_id = u.id WHERE cr.requestee_id = $1 AND cr.status = 'pending' ORDER BY cr.created_at DESC`, [userId]); res.json(result.rows); } catch (error) { console.error('Get received requests error:', error); res.status(500).json({ error: 'Failed to get requests' }); } });
app.get('/api/chat-requests/sent', authenticate, async (req, res) => { try { const userId = req.user.id; const result = await pool.query(`SELECT cr.id, cr.requestee_id, cr.status, cr.created_at, u.email as requestee_email, u.name as requestee_name, u.avatar_url as requestee_avatar_url FROM chat_requests cr JOIN users u ON cr.requestee_id = u.id WHERE cr.requester_id = $1 ORDER BY cr.created_at DESC`, [userId]); res.json(result.rows); } catch (error) { console.error('Get sent requests error:', error); res.status(500).json({ error: 'Failed to get requests' }); } });
app.post('/api/chat-requests', authenticate, async (req, res) => { try { const requesterId = req.user.id; const { requesteeId } = req.body; if (!requesteeId) return res.status(400).json({ error: 'Requestee ID required' }); const existingContact = await pool.query(`SELECT id FROM chat_requests WHERE ((requester_id = $1 AND requestee_id = $2) OR (requester_id = $2 AND requestee_id = $1))`, [requesterId, requesteeId]); if (existingContact.rows.length > 0) return res.status(400).json({ error: 'Chat request already exists' }); const result = await pool.query('INSERT INTO chat_requests (requester_id, requestee_id, status) VALUES ($1, $2, $3) RETURNING *', [requesterId, requesteeId, 'pending']); res.json(result.rows[0]); notifyUser(requesteeId, { type: 'CHAT_REQUEST', request: result.rows[0] }); } catch (error) { console.error('Send request error:', error); res.status(500).json({ error: 'Failed to send request' }); } });
app.post('/api/chat-requests/:requestId/accept', authenticate, async (req, res) => { try { const { requestId } = req.params; const userId = req.user.id; const result = await pool.query(`UPDATE chat_requests SET status = 'accepted', updated_at = NOW() WHERE id = $1 AND requestee_id = $2 RETURNING *`, [requestId, userId]); if (result.rows.length === 0) return res.status(404).json({ error: 'Request not found' }); res.json({ success: true }); notifyUser(result.rows[0].requester_id, { type: 'CHAT_REQUEST_ACCEPTED', requestId }); } catch (error) { console.error('Accept request error:', error); res.status(500).json({ error: 'Failed to accept request' }); } });
app.post('/api/chat-requests/:requestId/decline', authenticate, async (req, res) => { try { const { requestId } = req.params; const userId = req.user.id; const result = await pool.query(`UPDATE chat_requests SET status = 'declined', updated_at = NOW() WHERE id = $1 AND requestee_id = $2 RETURNING *`, [requestId, userId]); if (result.rows.length === 0) return res.status(404).json({ error: 'Request not found' }); res.json({ success: true }); } catch (error) { console.error('Decline request error:', error); res.status(500).json({ error: 'Failed to decline request' }); } });
app.get('/api/chat-requests/status/:userId', authenticate, async (req, res) => { try { const currentUserId = req.user.id; const { userId } = req.params; const result = await pool.query(`SELECT id, status, requester_id FROM chat_requests WHERE (requester_id = $1 AND requestee_id = $2) OR (requester_id = $2 AND requestee_id = $1)`, [currentUserId, userId]); if (result.rows.length === 0) return res.json({ status: null, isContact: false, isRequester: false }); const request = result.rows[0]; res.json({ status: request.status, isContact: request.status === 'accepted', isRequester: request.requester_id === currentUserId, requestId: request.id }); } catch (error) { console.error('Get request status error:', error); res.status(500).json({ error: 'Failed to get status' }); } });
app.get('/api/chats', authenticate, async (req, res) => { try { const userId = req.user.id; const result = await pool.query(`SELECT c.id, c.name, c.type, c.created_at, c.last_message, c.last_message_at, CASE WHEN c.type = 'direct' THEN (SELECT u.id FROM users u WHERE u.id IN (SELECT user_id FROM chat_participants WHERE chat_id = c.id AND user_id != $1) LIMIT 1) ELSE NULL END as other_user_id, CASE WHEN c.type = 'direct' THEN (SELECT u.name FROM users u WHERE u.id IN (SELECT user_id FROM chat_participants WHERE chat_id = c.id AND user_id != $1) LIMIT 1) ELSE NULL END as other_user_name, CASE WHEN c.type = 'direct' THEN (SELECT u.email FROM users u WHERE u.id IN (SELECT user_id FROM chat_participants WHERE chat_id = c.id AND user_id != $1) LIMIT 1) ELSE NULL END as other_user_email FROM chats c JOIN chat_participants cp ON c.id = cp.chat_id WHERE cp.user_id = $1 ORDER BY c.last_message_at DESC NULLS LAST, c.created_at DESC`, [userId]); res.json(result.rows); } catch (error) { console.error('Get chats error:', error); res.status(500).json({ error: 'Failed to get chats' }); } });
app.post('/api/chats/direct', authenticate, async (req, res) => { try { const userId = req.user.id; const { otherUserId } = req.body; if (!otherUserId) return res.status(400).json({ error: 'Other user ID required' }); const existing = await pool.query(`SELECT c.* FROM chats c JOIN chat_participants cp1 ON c.id = cp1.chat_id AND cp1.user_id = $1 JOIN chat_participants cp2 ON c.id = cp2.chat_id AND cp2.user_id = $2 WHERE c.type = 'direct' LIMIT 1`, [userId, otherUserId]); if (existing.rows.length > 0) return res.json(existing.rows[0]); const chatResult = await pool.query('INSERT INTO chats (type, name, created_by) VALUES ($1, $2, $3) RETURNING *', ['direct', 'Direct Chat', userId]); const chat = chatResult.rows[0]; await pool.query('INSERT INTO chat_participants (chat_id, user_id) VALUES ($1, $2), ($1, $3)', [chat.id, userId, otherUserId]); res.json(chat); } catch (error) { console.error('Create direct chat error:', error); res.status(500).json({ error: 'Failed to create chat' }); } });
app.get('/api/messages/:chatId', authenticate, async (req, res) => { try { const { chatId } = req.params; const { limit = 50, before } = req.query; const query = before ? `SELECT m.id, m.chat_id, m.sender_id, m.content, m.type, m.file_name, m.file_url, m.file_size, m.mime_type, m.created_at, m.deleted_at, u.name as sender_name, u.email as sender_email, u.avatar_url as sender_avatar FROM messages m JOIN users u ON m.sender_id = u.id WHERE m.chat_id = $1 AND m.created_at < $3 ORDER BY m.created_at DESC LIMIT $2` : `SELECT m.id, m.chat_id, m.sender_id, m.content, m.type, m.file_name, m.file_url, m.file_size, m.mime_type, m.created_at, m.deleted_at, u.name as sender_name, u.email as sender_email, u.avatar_url as sender_avatar FROM messages m JOIN users u ON m.sender_id = u.id WHERE m.chat_id = $1 ORDER BY m.created_at DESC LIMIT $2`; const params = before ? [chatId, limit, before] : [chatId, limit]; const result = await pool.query(query, params); res.json(result.rows.reverse()); } catch (error) { console.error('Get messages error:', error); res.status(500).json({ error: 'Failed to get messages' }); } });
app.post('/api/messages', authenticate, async (req, res) => { try { const { id, chatId, content, type, fileName, fileUrl, fileSize, mimeType } = req.body; const senderId = req.user.id; await pool.query('INSERT INTO messages (id, chat_id, sender_id, content, type, file_name, file_url, file_size, mime_type) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) ON CONFLICT (id) DO NOTHING', [id, chatId, senderId, content, type || 'text', fileName, fileUrl, fileSize, mimeType]); const userResult = await pool.query('SELECT name, email, avatar_url FROM users WHERE id = $1', [senderId]); const sender = userResult.rows[0]; notifyChat(chatId, { type: 'NEW_MESSAGE', data: { messageId: id, chatId, senderId, senderName: sender.name, content, type: type || 'text', timestamp: new Date().toISOString() } }, senderId); res.json({ success: true }); } catch (error) { console.error('Save message error:', error); res.status(500).json({ error: 'Failed to save message' }); } });
app.post('/api/messages/read', authenticate, async (req, res) => { try { const { messageIds, chatId } = req.body; const userId = req.user.id; if (!messageIds || messageIds.length === 0) return res.json({ success: true }); for (const messageId of messageIds) { await pool.query('INSERT INTO message_reads (message_id, user_id, chat_id) VALUES ($1, $2, $3) ON CONFLICT (message_id, user_id) DO NOTHING', [messageId, userId, chatId]); } const messagesResult = await pool.query('SELECT DISTINCT sender_id FROM messages WHERE id = ANY($1)', [messageIds]); messagesResult.rows.forEach(row => { if (row.sender_id !== userId) { notifyUser(row.sender_id, { type: 'MESSAGES_READ', data: { messageIds, chatId, readBy: userId } }); } }); res.json({ success: true }); } catch (error) { console.error('Mark as read error:', error); res.status(500).json({ error: 'Failed to mark as read' }); } });
app.post('/api/messages/reads', authenticate, async (req, res) => { try { const { messageIds } = req.body; if (!messageIds || messageIds.length === 0) return res.json({}); const result = await pool.query(`SELECT mr.message_id, mr.user_id, mr.read_at, u.name, u.email FROM message_reads mr JOIN users u ON mr.user_id = u.id WHERE mr.message_id = ANY($1)`, [messageIds]); const receipts = {}; result.rows.forEach(row => { if (!receipts[row.message_id]) receipts[row.message_id] = []; receipts[row.message_id].push({ user_id: row.user_id, name: row.name, email: row.email, read_at: row.read_at }); }); res.json(receipts); } catch (error) { console.error('Get read receipts error:', error); res.status(500).json({ error: 'Failed to get read receipts' }); } });
app.post('/api/messages/typing', authenticate, async (req, res) => { try { const { chatId, isTyping } = req.body; const userId = req.user.id; const userResult = await pool.query('SELECT name FROM users WHERE id = $1', [userId]); const userName = userResult.rows[0]?.name || 'Unknown'; notifyChat(chatId, { type: 'TYPING', data: { chatId, userId, userName, isTyping } }, userId); res.json({ success: true }); } catch (error) { console.error('Typing indicator error:', error); res.status(500).json({ error: 'Failed to send typing indicator' }); } });
server.listen(PORT, '0.0.0.0', () => { console.log(`Summit server with WebSocket running on port ${PORT}`); console.log(`WebSocket endpoint: ws://localhost:${PORT}/ws`); });
